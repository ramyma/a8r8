import { useCallback, useMemo, useState } from "react";
import { FromToProps, isEmptyArray, take } from "@remirror/core";

import { useExtensionEvent, useHelpers } from "@remirror/react-core";
import {
  MenuNavigationOptions,
  UseMenuNavigationReturn,
  useMenuNavigation,
} from "@remirror/react-hooks";
import { CustomExtension } from "./CustomExtension";
import uFuzzy from "@leeoniya/ufuzzy";
import { ExtrasSuggestHandlerCommand } from "./customExtentionUtils";
import useLoras from "../../hooks/useLoras";
import useEmbeddings from "../../hooks/useEmbeddings";

export interface CompletionOptionsState {
  /**
   * The query value after the activation character.
   */
  query: string;
  /**
      /**
       * The range of the matching suggestion.
       */
  range: FromToProps;
  /**
   * `true` when this change was triggered by an exit. Both `exit` and `change`
   * can be true when jumping between matching suggestion positions in the
   * document.
   */
  exit: boolean;

  /**
   * The list of extras generated by the query.
   *
   * @defaultValue []
   */
  list: string[];

  /**
   * The command to run to replace the query with the request extra.
   *
   * @defaultValue undefined
   */
  apply: ExtrasSuggestHandlerCommand;
}

export type UseCompletionProps = MenuNavigationOptions;

export interface UseExtrasReturn extends UseMenuNavigationReturn<string> {
  /**
   * The state of the current query, only available when active.
   */
  state: CompletionOptionsState | null;
}

const commands = ["lora", "embedding"];
const opts = { intraMode: 1 };

const uf = new uFuzzy(opts);

/**
 * This hook provides the state for setting up an extras state change handler. It
 * applies the keybindings and the required change handlers.
 */
export function useExtras(props: UseCompletionProps = {}): UseExtrasReturn {
  const { direction, dismissKeys, focusOnClick, submitKeys } = props;
  const [state, setState] = useState<CompletionOptionsState | null>(null);
  const helpers = useHelpers();
  const items = state?.list ?? [];
  const isOpen = !!state;

  const onDismiss = useCallback(() => {
    if (!state) {
      return false;
    }

    // Ignore the current mention so that it doesn't show again for this
    // matching area
    helpers
      .getSuggestMethods()
      .addIgnored({ from: state.range.from, name: "extra", specific: true });

    setState({ ...state, exit: true });
    return true;
  }, [helpers, state]);

  const onSubmit = useCallback(
    (extra: string) => {
      if (!state || isEmptyArray(state.list)) {
        return false;
      }

      state.apply(extra);

      return true;
    },
    [state]
  );

  const { loras } = useLoras();
  const lorasByName = useCallback(
    () => loras?.map(({ name }) => name) ?? [],
    [loras]
  );

  const { embeddings } = useEmbeddings();

  const menu = useMenuNavigation<string>({
    items,
    isOpen,
    onDismiss,
    onSubmit,
    direction,
    dismissKeys,
    focusOnClick,
    submitKeys,
  });
  const { setIndex } = menu;

  const onChange = useCallback(
    (props) => {
      const { change, exit, query, apply, range } = props;

      if (change) {
        const idxs = uf.filter(commands, query);
        // const info = uf.info(idxs, commands, query);
        // const order = uf.sort(info, commands, query);
        // console.log({ idxs, info, order });
        const filtered = idxs?.length
          ? idxs?.map((i) => commands[i])
          : !query
          ? commands
          : [];
        setIndex(0);
        setState({
          list: filtered, //take(filtered, 20),
          apply: (code) => {
            setState(null);
            return apply(code);
          },
          range,
          query,
          exit,
        });
      }

      if (exit) {
        setState(null);
      }
    },
    [setIndex]
  );

  const onLoraChange = useCallback(
    (props) => {
      const { change, exit, query, apply, range } = props;
      const loras = lorasByName();
      if (change) {
        const idxs = uf.filter(loras, query);
        // const info = uf.info(idxs, loras, query);
        // const order = uf.sort(info, loras, query);
        // console.log({ idxs, info, order });
        const filtered = idxs?.length
          ? idxs?.map((i) => loras[i])
          : !query
          ? loras
          : [];
        setIndex(0);
        setState({
          list: take(filtered, 20),
          apply: (code) => {
            setState(null);
            return apply(code);
          },
          range,
          query,
          exit,
        });
      }

      if (exit) {
        setState(null);
      }
    },
    [lorasByName, setIndex]
  );

  const onEmbeddingChange = useCallback(
    (props) => {
      const { change, exit, query, apply, range } = props;

      if (change) {
        const idxs = uf.filter(embeddings, query);
        // const info = uf.info(idxs, loras, query);
        // const order = uf.sort(info, loras, query);
        // console.log({ idxs, info, order });
        const filtered = idxs?.length
          ? idxs?.map((i) => embeddings[i])
          : !query
          ? embeddings
          : [];
        setIndex(0);
        setState({
          list: take(filtered, 20),
          apply: (code) => {
            setState(null);
            return apply(code);
          },
          range,
          query,
          exit,
        });
      }

      if (exit) {
        setState(null);
      }
    },
    [embeddings, setIndex]
  );

  useExtensionEvent(CustomExtension, "suggestCommand", onChange);
  useExtensionEvent(CustomExtension, "suggestLora", onLoraChange);
  useExtensionEvent(CustomExtension, "suggestEmbedding", onEmbeddingChange);

  return useMemo(() => ({ ...menu, state }), [menu, state]);
}
